import "yue"
const json = do
	local success, result

	if success, result := pcall require, "cojson"
		result
	elseif success, result := pcall require, "cjson"
		result
	elseif success, result := pcall require, "json"
		result
	else
		error "Could not find a JSON-module for YueScript! Please install one."


const send = (data, raw = false) ->
	if not raw
		data = json.encode(data)::gsub "[\r\n]", ""

	assert type(data) == "string"

	io.stdout::write data, "\n"
	io.stdout::flush!
	return


const recieve = () ->
	const rawData = io.stdin::read "*l"

	const data = if type(rawData) == "string"
		json.decode rawData
	else
		nil

	data, rawData

while true
	const input, rawInput = recieve!

	if input == nil
		send "{}", true
		return

	try
		config = if content := input.config?.content
			try? yue.loadstring(content)!

		configDir = input.config?.dir

		config ??= {
			lint_global: true
		}

		path = config.options?.path ?? ""
		if configDir and config.include and type(config.include) == "table"
			includes = ["#{configDir}/?.lua",]
			for include in *config.include
				if type(include) == "string"
					includes[] = "#{configDir}/#{include}/?.lua"
			path ..= ";" if path ~= ""
			path ..= table.concat includes, ";"

		oldPath = package.path
		package.path ..= ";" .. path

		success, messages, transpiledLuaCode = yue.check input.sourceCode, config

		package.path = oldPath

		if messages
			:globals = config
			globals = {name, true for name in *globals} if type(globals) == "table"
			messages = [message for message in *messages when message[1] == "error" or (message[1] == "global" and not _G[message[2]] and (not globals or not globals[message[2]]))]
		else
			messages = []

		send input.isSaveEvent and {
			:success
			:transpiledLuaCode
			include: config.include
			:configDir
			build: config.build
			:messages
		} or {
			:success
			:messages
		}
	catch err
		send
			success: false
			messages: [ ["error", err, 1, 1],]
